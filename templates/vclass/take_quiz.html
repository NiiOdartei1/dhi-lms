{% extends 'vclass/base_vclass.html' %}
{% block title %}Take Quiz – {{ quiz_json.title }}{% endblock %}

{% block content %}
<div class="container-fluid py-4 v-quiz">
  <div class="d-flex justify-content-between align-items-center mb-3">
    <h4 id="quiz-title" class="mb-0">{{ quiz_json.title }}</h4>

    <div class="text-end">
      <div id="timer-wrapper" role="timer" aria-atomic="true" aria-live="polite" class="small text-muted">
        <div><strong>Time Left:</strong></div>
        <div id="timer" class="fw-bold fs-5 text-danger" aria-label="Time remaining">--:--</div>
      </div>
    </div>
  </div>

  <div class="row mb-3 gx-3">
    <div class="col-lg-8">
      <div class="progress mb-2" id="progress-bar" role="progressbar"
           aria-valuemin="0" aria-valuemax="{{ quiz_json.questions|length }}" aria-valuenow="0"
           style="height:28px; background:#e9f7ee;">
        <div id="progress-inner" class="progress-bar" style="width:0%; display:flex; align-items:center; justify-content:center; background:var(--v-accent);">
          <span id="progress-text">0/{{ quiz_json.questions|length }} (0%)</span>
        </div>
      </div>
    </div>

    <div class="col-lg-4 text-lg-end">
      <div class="d-inline-block me-3">
        <div class="small text-muted">Total</div>
        <div id="summary-total" class="fw-bold">{{ quiz_json.questions|length }}</div>
      </div>
      <div class="d-inline-block me-3">
        <div class="small text-muted">Answered</div>
        <div id="summary-answered" class="fw-bold">0</div>
      </div>
      <div class="d-inline-block">
        <div class="small text-muted">Unanswered</div>
        <div id="summary-unanswered" class="fw-bold">{{ quiz_json.questions|length }}</div>
      </div>
    </div>
  </div>

  <div class="row">
    <div class="col-lg-9">
      <form id="quiz-form" method="POST" action="{{ url_for('vclass.submit_quiz', quiz_id=quiz_json.id) }}">
        <input type="hidden" name="csrf_token" value="{{ csrf_token() }}">
        <div id="questions-container" class="mb-4" aria-live="polite"></div>

        <nav class="mt-2" aria-label="Quiz Navigation">
          <ul class="pagination justify-content-center" id="pagination"></ul>
        </nav>

        <div id="submit-container" class="text-end mt-3">
          <button type="submit" class="btn btn-success" id="submit-btn">Submit Quiz</button>
        </div>
      </form>
    </div>

    <aside class="col-lg-3">
      <div class="card shadow-sm">
        <div class="card-body">
          <h6 class="card-title mb-2">Question Palette</h6>
          <div class="small text-muted mb-2">Click a number to jump to that question. Green = answered.</div>
          <div id="question-palette" class="d-grid gap-2" style="grid-template-columns: repeat(auto-fill, minmax(44px, 1fr));"></div>

          <div class="mt-3 small text-muted">
            Legend:
            <span class="badge bg-success me-1">Answered</span>
            <span class="badge bg-light border text-dark me-1">Unanswered</span>
            <span class="badge" style="background:var(--v-accent); color:#fff;">Current</span>
          </div>
        </div>
      </div>
    </aside>
  </div>
</div>

<script id="quiz-data" type="application/json">{{ quiz_json | tojson }}</script>

<script>
(() => {
  'use strict';

  // -----------------------
  // Safe parse of quiz JSON
  // -----------------------
  let quiz;
  try {
    quiz = JSON.parse(document.getElementById('quiz-data').textContent || '{}');
  } catch (err) {
    console.error('Invalid quiz JSON', err);
    return;
  }

  if (!quiz || !quiz.id) {
    console.error('No quiz data found');
    return;
  }

  // -----------------------
  // DOM references
  // -----------------------
  const timerEl = document.getElementById('timer');
  const questionsContainer = document.getElementById('questions-container');
  const paginationEl = document.getElementById('pagination');
  const progressInner = document.getElementById('progress-inner');
  const progressText = document.getElementById('progress-text');
  const summaryAnswered = document.getElementById('summary-answered');
  const summaryUnanswered = document.getElementById('summary-unanswered');
  const summaryTotal = document.getElementById('summary-total');
  const paletteEl = document.getElementById('question-palette');
  const form = document.getElementById('quiz-form');

  if (!form || !questionsContainer || !paginationEl || !paletteEl) {
    console.error('Quiz: essential DOM elements missing');
    return;
  }

  // -----------------------
  // Config / state
  // -----------------------
  const quizId = quiz.id;
  const duration = (quiz.duration_minutes || 0) * 60; // seconds
  const perPage = 5;
  const questions = Array.isArray(quiz.questions) ? quiz.questions : [];
  const totalQuestions = questions.length;
  const totalPages = Math.max(1, Math.ceil(totalQuestions / perPage));
  let currentPage = 1;
  const answers = {};
  const LS_KEY = `vclass_quiz_answers_${quizId}`;

  // -----------------------
  // CSRF helpers
  // -----------------------
  function getCsrfToken() {
    const meta = document.querySelector('meta[name="csrf-token"]');
    if (meta && meta.content) return meta.content;
    const hidden = document.querySelector('input[name="csrf_token"]');
    if (hidden) return hidden.value;
    return '';
  }

  async function csrfFetch(url, opts = {}) {
    opts = Object.assign({}, opts);
    opts.headers = Object.assign({}, opts.headers || {});

    if (opts.body && !(opts.body instanceof FormData) && !opts.headers['Content-Type']) {
      opts.headers['Content-Type'] = 'application/json';
    }

    const token = getCsrfToken();
    if (token) {
      opts.headers['X-CSRFToken'] = token;
      opts.headers['X-CSRF-Token'] = token;
    }

    opts.credentials = opts.credentials || 'include';
    return fetch(url, opts);
  }

  // -----------------------
  // Utility: debounce
  // -----------------------
  function debounce(fn, wait = 300) {
    let timer = null;
    return (...args) => {
      clearTimeout(timer);
      timer = setTimeout(() => fn(...args), wait);
    };
  }

  // -----------------------
  // Autosave (debounced)
  // -----------------------
  const autosaveNetwork = debounce(async (qid, value) => {
    try {
      const payload = { quiz_id: quizId, question_id: qid, selected_option_id: null, answer_text: null };

      if (Array.isArray(value)) {
        payload.answer_text = JSON.stringify(value);
      } else if (typeof value === 'number' || (!isNaN(value) && String(value).trim() !== '')) {
        payload.selected_option_id = (typeof value === 'number') ? value : (isNaN(Number(value)) ? null : Number(value));
        if (payload.selected_option_id === null) payload.answer_text = String(value);
      } else {
        payload.answer_text = value != null ? String(value) : null;
      }

      await csrfFetch('{{ url_for("vclass.autosave_answer") }}', {
        method: 'POST',
        body: JSON.stringify(payload)
      });
    } catch (err) {
      console.warn('Autosave failed:', err);
    }
  }, 300);

  // -----------------------
  // Local persistence
  // -----------------------
  function persistLocal() {
    try {
      localStorage.setItem(LS_KEY, JSON.stringify(answers));
    } catch (e) {}
  }

  function saveAnswer(qid, val) {
    answers[qid] = val;
    persistLocal();
    autosaveNetwork(qid, val);
    updateProgress();
    updatePalette();
  }

  // -----------------------
  // Initialization flow
  // -----------------------
  (async function initFlow() {
    // ✅ IMPORTANT: For fresh quiz start, START WITH BLANK FORM (no restored answers)
    // Only restore if user explicitly confirms they want previous session's answers
    
    // Check for server-saved answers from a previous attempt
    try {
      const res = await csrfFetch('{{ url_for("vclass.get_saved_answers", quiz_id=quiz_json.id) }}', { method: 'GET' });
      if (res.ok) {
        const serverAnswers = await res.json();
        if (serverAnswers && Object.keys(serverAnswers).length > 0) {
          // Server has saved answers from a previous session
          const restore = confirm('Saved answers from a previous session were found. Restore them now? Click Cancel to start fresh.');
          if (restore) {
            // Restore server-saved answers
            Object.keys(serverAnswers).forEach(k => {
              try { answers[Number(k)] = serverAnswers[k]; } catch (e) { answers[k] = serverAnswers[k]; }
            });
          } else {
            // User chose to start fresh — clear localStorage to prevent old cached answers
            localStorage.removeItem(LS_KEY);
          }
        } else {
          // No server-saved answers — start fresh and clear any old localStorage data
          localStorage.removeItem(LS_KEY);
        }
      } else {
        // Failed to fetch — clear localStorage to ensure blank start
        localStorage.removeItem(LS_KEY);
      }
    } catch (e) {
      console.warn('Failed to fetch saved answers', e);
      // On error, clear localStorage to ensure blank start
      localStorage.removeItem(LS_KEY);
    }

    // Get server start time
    const serverStartStr = "{{ session.get('quiz_' ~ quiz_json.id ~ '_start_time','')[:19] }}";
    let serverStartTime = null;
    try {
      if (serverStartStr && serverStartStr.trim() !== '') {
        serverStartTime = new Date(serverStartStr + 'Z');
        if (isNaN(serverStartTime.getTime())) serverStartTime = null;
      }
    } catch (e) {
      serverStartTime = null;
    }

    // If no server start time, create one
    if (!serverStartTime) {
      try {
        const startRes = await csrfFetch('{{ url_for("vclass.start_quiz_timer", quiz_id=quiz_json.id) }}', {
          method: 'POST',
          body: JSON.stringify({})
        });
        if (startRes.ok) {
          return window.location.reload();
        }
      } catch (e) {
        console.warn('Failed to start timer', e);
      }
    }

    initUI(serverStartTime);
  })();

  // -----------------------
  // UI initialization
  // -----------------------
  function initUI(serverStartTime) {
    console.log('Initializing UI with', totalQuestions, 'questions');
    renderPalette();
    renderQuestions(currentPage);
    renderPagination();
    updateProgress();

    if (serverStartTime instanceof Date && !isNaN(serverStartTime.getTime())) {
      console.log('Starting countdown from', serverStartTime);
      startCountdown(serverStartTime);
    }
  }

  // -----------------------
  // Palette (question jump grid)
  // -----------------------
  function renderPalette() {
    paletteEl.innerHTML = '';
    for (let i = 0; i < totalQuestions; i++) {
      const btn = document.createElement('button');
      btn.type = 'button';
      btn.className = 'btn btn-sm border palette-btn unanswered';
      btn.style.minHeight = '40px';
      btn.style.minWidth = '42px';
      btn.setAttribute('data-idx', i);
      btn.setAttribute('aria-label', `Question ${i + 1}`);
      btn.textContent = String(i + 1);

      btn.addEventListener('click', () => {
        const page = Math.floor(i / perPage) + 1;
        renderQuestions(page);
        setTimeout(() => {
          const first = questionsContainer.querySelector('input, textarea');
          if (first) first.focus();
        }, 40);
      });

      paletteEl.appendChild(btn);
    }
    updatePalette();
  }

  function updatePalette() {
    const btns = Array.from(paletteEl.querySelectorAll('button'));
    const curStart = (currentPage - 1) * perPage;
    const curEnd = curStart + perPage - 1;

    btns.forEach((btn, idx) => {
      const q = questions[idx];
      btn.classList.remove('current');
      const ans = q && answers[q.id];
      const answered = ans !== undefined && ans !== null && (Array.isArray(ans) ? ans.some(x => String(x).trim() !== '') : String(ans).trim() !== '');
      btn.classList.toggle('answered', answered);
      btn.classList.toggle('unanswered', !answered);
      btn.setAttribute('aria-pressed', answered ? 'true' : 'false');
      if (idx >= curStart && idx <= curEnd) btn.classList.add('current');
    });

    const answeredCount = Object.keys(answers).filter(k => {
      const v = answers[k];
      return v !== undefined && v !== null && (Array.isArray(v) ? v.some(x => String(x).trim() !== '') : String(v).trim() !== '');
    }).length;

    if (summaryAnswered) summaryAnswered.textContent = String(answeredCount);
    if (summaryUnanswered) summaryUnanswered.textContent = String(Math.max(0, totalQuestions - answeredCount));
  }

  // -----------------------
  // Render questions for a page
  // -----------------------
  function renderQuestions(page) {
    currentPage = Math.min(Math.max(1, page), totalPages);
    questionsContainer.innerHTML = '';

    const start = (currentPage - 1) * perPage;
    const end = Math.min(start + perPage, totalQuestions);

    console.log('Rendering questions', start, 'to', end);

    for (let i = start; i < end; i++) {
      const q = questions[i];
      if (!q) {
        console.warn('Question at index', i, 'is missing');
        continue;
      }

      const block = document.createElement('div');
      block.className = 'mb-3 p-3 border rounded';

      const header = document.createElement('div');
      header.className = 'mb-2';
      header.innerHTML = `<strong>Question ${i + 1}:</strong>`;
      block.appendChild(header);

      if (q.question_text) {
        const qText = document.createElement('div');
        qText.className = 'mb-2';
        qText.textContent = q.question_text;
        block.appendChild(qText);
      }

      const qType = (q.question_type || '').toLowerCase();
      console.log('Question', q.id, 'type:', qType, 'options:', q.options?.length || 0);

      // Multiple Choice
      if ((qType === 'mcq' || qType === 'multiple_choice') && Array.isArray(q.options) && q.options.length > 0) {
        q.options.forEach(opt => {
          const wrap = document.createElement('div');
          wrap.className = 'form-check';

          const radio = document.createElement('input');
          radio.type = 'radio';
          radio.name = `answers[${q.id}]`;
          radio.id = `q${q.id}_o${opt.id}`;
          radio.value = opt.id;
          radio.className = 'form-check-input';
          radio.checked = String(answers[q.id]) === String(opt.id);

          radio.addEventListener('change', () => {
            const parsed = parseInt(opt.id, 10) || opt.id;
            saveAnswer(q.id, parsed);
          });

          const label = document.createElement('label');
          label.htmlFor = radio.id;
          label.className = 'form-check-label';
          label.textContent = opt.text || '';

          wrap.appendChild(radio);
          wrap.appendChild(label);
          block.appendChild(wrap);
        });
      }
      // Fill-in-the-blank
      else if (['fill_blank', 'multi_blank', 'fill_in', 'fill-in', 'fill_in_blank', 'multi-blank'].includes(qType)) {
        const wrapper = document.createElement('div');
        wrapper.className = 'mb-3';

        const numBlanks = (String(q.question_text || '').match(/_{3,}|_____/g) || []).length || 1;

        for (let idx = 0; idx < numBlanks; idx++) {
          const input = document.createElement('input');
          input.type = 'text';
          input.className = 'form-control my-2';
          input.name = `answers[${q.id}][]`;
          input.placeholder = `Answer for blank ${idx + 1}`;
          input.value = '';

          input.addEventListener('input', (e) => {
            const i = parseInt(e.target.getAttribute('data-idx'), 10);
            if (!Array.isArray(answers[q.id])) answers[q.id] = [];
            answers[q.id][i] = e.target.value;
            saveAnswer(q.id, answers[q.id]);
          });

          input.setAttribute('data-idx', idx);
          wrapper.appendChild(input);
        }

        block.appendChild(wrapper);
      }
      // Short Answer
      else if (qType === 'manual' || qType === 'short_answer' || qType === 'text') {
        const ta = document.createElement('textarea');
        ta.className = 'form-control';
        ta.name = `answers[${q.id}]`;
        ta.rows = 2;
        ta.placeholder = 'Type your answer here...';
        ta.value = answers[q.id] || '';

        ta.addEventListener('input', (e) => {
          saveAnswer(q.id, e.target.value);
        });

        block.appendChild(ta);
      }
      // Unsupported
      else {
        const unsupported = document.createElement('div');
        unsupported.className = 'text-muted';
        unsupported.textContent = `Unsupported question type: ${qType}`;
        block.appendChild(unsupported);
      }

      questionsContainer.appendChild(block);
    }

    renderPagination();
    updatePalette();
  }

  // -----------------------
  // Pagination
  // -----------------------
  function renderPagination() {
    paginationEl.innerHTML = '';

    function makeLi(pageNum, text, disabled = false, active = false) {
      const li = document.createElement('li');
      li.className = 'page-item' + (disabled ? ' disabled' : '') + (active ? ' active' : '');

      const a = document.createElement('a');
      a.className = 'page-link';
      a.href = '#';
      a.textContent = text || String(pageNum);
      a.addEventListener('click', (e) => {
        e.preventDefault();
        if (!disabled) renderQuestions(pageNum);
      });
      li.appendChild(a);
      return li;
    }

    paginationEl.appendChild(makeLi(currentPage - 1, '« Prev', currentPage === 1));
    for (let p = 1; p <= totalPages; p++) {
      paginationEl.appendChild(makeLi(p, null, false, p === currentPage));
    }
    paginationEl.appendChild(makeLi(currentPage + 1, 'Next »', currentPage === totalPages));
  }

  // -----------------------
  // Progress bar update
  // -----------------------
  function updateProgress() {
    const quizQuestionIds = questions.map(q => q.id);
    const answeredCount = quizQuestionIds.filter(qid => {
      const v = answers[qid];
      if (v === undefined || v === null) return false;
      if (Array.isArray(v)) return v.some(x => String(x).trim() !== '');
      return String(v).trim() !== '';
    }).length;

    const percent = totalQuestions ? Math.round((answeredCount / totalQuestions) * 100) : 0;

    if (progressInner) progressInner.style.width = percent + '%';
    if (progressText) progressText.textContent = `${answeredCount}/${totalQuestions} (${percent}%)`;
    if (summaryAnswered) summaryAnswered.textContent = String(answeredCount);
    if (summaryUnanswered) summaryUnanswered.textContent = String(Math.max(0, totalQuestions - answeredCount));
  }

  // -----------------------
  // Form submission
  // -----------------------
  form.addEventListener('submit', (e) => {
    // Inject answers
    document.querySelectorAll('input[data-autogen="true"]').forEach(n => n.remove());
    Object.entries(answers).forEach(([qid, val]) => {
      if (Array.isArray(val)) {
        val.forEach(v => {
          const hidden = document.createElement('input');
          hidden.type = 'hidden';
          hidden.name = `answers[${qid}][]`;
          hidden.value = v == null ? '' : String(v);
          hidden.setAttribute('data-autogen', 'true');
          form.appendChild(hidden);
        });
      } else {
        const hidden = document.createElement('input');
        hidden.type = 'hidden';
        hidden.name = `answers[${qid}]`;
        hidden.value = val == null ? '' : String(val);
        hidden.setAttribute('data-autogen', 'true');
        form.appendChild(hidden);
      }
    });

    const unanswered = totalQuestions - Object.keys(answers).filter(k => {
      const v = answers[k];
      return v !== undefined && v !== null && (Array.isArray(v) ? v.some(x => String(x).trim() !== '') : String(v).trim() !== '');
    }).length;

    if (unanswered > 0) {
      if (!confirm(`You have ${unanswered} unanswered question(s). Submit anyway?`)) {
        e.preventDefault();
        return;
      }
    }
  });

  // -----------------------
  // Timer / auto-submit
  // -----------------------
  function startCountdown(startTime) {
    if (!(startTime instanceof Date) || isNaN(startTime.getTime())) {
      console.error('Invalid startTime', startTime);
      return;
    }

    (function tick() {
      const now = new Date();
      const elapsed = Math.floor((now - startTime) / 1000);
      const left = duration - elapsed;

      if (left <= 0) {
        if (timerEl) timerEl.textContent = '00:00';
        form.submit();
        return;
      }

      if (timerEl) {
        const h = Math.floor(left / 3600);
        const m = Math.floor((left % 3600) / 60);
        const s = left % 60;
        if (h > 0) {
          timerEl.textContent = `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
        } else {
          timerEl.textContent = `${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
        }
      }
      setTimeout(tick, 1000);
    })();
  }

  // Debug
  window.vclass_quiz = { answers, questions, totalQuestions };
  console.log('Quiz script loaded. Total questions:', totalQuestions);
})();
</script>

<style>
#question-palette .palette-btn {
  border-radius: 6px;
  min-width: 42px;
  min-height: 42px;
  font-weight: 700;
  padding: 6px 8px;
  transition: background .18s ease, transform .12s ease, box-shadow .12s ease;
}
#question-palette .palette-btn.unanswered {
  background-color: #f8f9fa;
  color: #212529;
  border-color: rgba(0,0,0,0.06);
}
#question-palette .palette-btn.answered {
  background-color: #198754;
  color: #fff;
  border-color: #198754;
}
#question-palette .palette-btn.current {
  background-color: var(--v-accent, #0d6efd);
  color: #fff;
  box-shadow: 0 6px 18px rgba(13,110,253,0.12);
  transform: translateY(-2px);
}
#question-palette .palette-btn:focus,
#question-palette .palette-btn:hover { outline: none; filter: brightness(0.96); }
.progress-bar { transition: width .4s ease; }
</style>
{% endblock %}
